#!/bin/bash

# Samsung TV Test Runner Script
# Usage: ./run test "@loginTest" or ./run test "features/validLogin.feature"

set -e  # Exit on any error

# Setup Node.js version using nvm
setup_node_version() {
    # Load nvm if available
    export NVM_DIR="$HOME/.nvm"
    if [ -s "$NVM_DIR/nvm.sh" ]; then
        source "$NVM_DIR/nvm.sh"
        
        # Use Node.js 22.11.0 (required for this project)
        if nvm use 22.11.0 >/dev/null 2>&1; then
            log_info "Using Node.js $(node --version)"
        else
            log_warning "Node.js 22.11.0 not found, installing..."
            nvm install 22.11.0
            nvm use 22.11.0
            log_success "Node.js 22.11.0 installed and activated"
        fi
    else
        # Check if node is available and meets minimum version
        if command -v node >/dev/null 2>&1; then
            local node_version=$(node --version | cut -d'v' -f2 | cut -d'.' -f1)
            if [ "$node_version" -lt 18 ]; then
                log_error "Node.js version 18+ required, but found $(node --version)"
                log_info "Please install Node.js 22.11.0 or higher"
                exit 1
            fi
            log_info "Using Node.js $(node --version)"
        else
            log_error "Node.js not found. Please install Node.js 22.11.0 or higher"
            exit 1
        fi
    fi
}

# Configuration - These can be overridden by environment variables
TV_IP="${SAMSUNG_TV_IP:-}"  # Will be auto-discovered if not set
TV_PORT="${SAMSUNG_TV_PORT:-26101}"
RC_TOKEN="${SAMSUNG_TV_RC_TOKEN:-58997311}"
APPIUM_PORT="${SAMSUNG_APPIUM_PORT:-4723}"
SDB_PATH="${SAMSUNG_SDB_PATH:-/Users/asad.zaman/tizen-studio/tools/sdb}"
APP_PACKAGE="${SAMSUNG_APP_PACKAGE:-gGnYSxMq0L.MLBTVSTG}"

# Auto-discovery settings
AUTO_DISCOVER_TV="${AUTO_DISCOVER_TV:-true}"
NETWORK_SCAN_TIMEOUT=10
CONFIG_FILE="${CONFIG_FILE:-$(dirname "$0")/.samsung-tv.conf}"

# Load configuration file if it exists
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        log_info "Loading configuration from $CONFIG_FILE"
        source "$CONFIG_FILE"
    fi
}

# Save configuration file
save_config() {
    log_info "Saving configuration to $CONFIG_FILE"
    cat > "$CONFIG_FILE" << EOF
# Samsung TV Configuration
# This file is automatically generated by the Samsung TV Test Runner
# You can modify these values or override them with environment variables

TV_IP="$TV_IP"
TV_PORT="$TV_PORT"
RC_TOKEN="$RC_TOKEN"
APPIUM_PORT="$APPIUM_PORT"
SDB_PATH="$SDB_PATH"
APP_PACKAGE="$APP_PACKAGE"

# Auto-discovery settings
AUTO_DISCOVER_TV="$AUTO_DISCOVER_TV"
NETWORK_SCAN_TIMEOUT=$NETWORK_SCAN_TIMEOUT

# Last updated: $(date)
EOF
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# TV Discovery Functions
discover_tv_via_sdb() {
    if [ ! -f "$SDB_PATH" ]; then
        return 1
    fi
    
    log_info "Scanning for Samsung TVs via SDB..."
    local devices=$($SDB_PATH devices 2>/dev/null | grep -E "device$|online$" | awk '{print $1}' | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+$")
    
    if [ -n "$devices" ]; then
        local first_device=$(echo "$devices" | head -1)
        local ip=$(echo "$first_device" | cut -d: -f1)
        local port=$(echo "$first_device" | cut -d: -f2)
        
        log_info "Found Samsung TV via SDB: $ip:$port"
        TV_IP="$ip"
        TV_PORT="$port"
        return 0
    fi
    
    return 1
}

discover_tv_via_network_scan() {
    log_info "Scanning local network for Samsung TVs..."
    
    # Get the local network range
    local local_ip=$(ifconfig | grep -E "inet [0-9]" | grep -v 127.0.0.1 | awk '{print $2}' | head -1)
    if [ -z "$local_ip" ]; then
        log_warning "Could not determine local IP address"
        return 1
    fi
    
    local network_base=$(echo "$local_ip" | cut -d. -f1-3)
    log_info "Scanning network range: ${network_base}.1-254"
    
    # Common Samsung TV ports to check
    local tv_ports="8002 26101"
    
    for port in $tv_ports; do
        log_info "Scanning for port $port..."
        
        # Use timeout and nc to scan common IPs quickly
        for i in $(seq 1 254); do
            local ip="${network_base}.${i}"
            
            # Skip common non-TV IPs
            case "$i" in
                1|255) continue ;;  # Network and broadcast
            esac
            
            # Quick port check with timeout
            if timeout 1 nc -z "$ip" "$port" 2>/dev/null; then
                log_info "Found device at $ip:$port - verifying if it's a Samsung TV..."
                
                # Try to verify it's a Samsung TV by checking if SDB can connect
                if [ -f "$SDB_PATH" ] && $SDB_PATH connect "$ip:$port" >/dev/null 2>&1; then
                    log_success "Confirmed Samsung TV at $ip:$port"
                    TV_IP="$ip"
                    TV_PORT="$port"
                    return 0
                fi
                
                # Fallback: if port 8002 is open, it's likely a Samsung TV
                if [ "$port" = "8002" ]; then
                    log_info "Port 8002 open at $ip - likely Samsung TV remote control port"
                    TV_IP="$ip"
                    TV_PORT="26101"  # Use standard debug port
                    return 0
                fi
            fi
        done
    done
    
    return 1
}

discover_tv_via_mdns() {
    log_info "Scanning for Samsung TVs via mDNS/Bonjour..."
    
    # Try to find Samsung TV services via dns-sd or avahi
    if command -v dns-sd >/dev/null 2>&1; then
        # macOS Bonjour
        timeout $NETWORK_SCAN_TIMEOUT dns-sd -B _samsung-tv._tcp local. 2>/dev/null | while read line; do
            if echo "$line" | grep -q "samsung"; then
                log_info "Found Samsung TV service via mDNS"
                # This would need more parsing to extract IP, but it's a good indicator
                return 0
            fi
        done
    elif command -v avahi-browse >/dev/null 2>&1; then
        # Linux Avahi
        timeout $NETWORK_SCAN_TIMEOUT avahi-browse -t _samsung-tv._tcp 2>/dev/null | while read line; do
            if echo "$line" | grep -q "samsung"; then
                log_info "Found Samsung TV service via Avahi"
                return 0
            fi
        done
    fi
    
    return 1
}

auto_discover_samsung_tv() {
    if [ "$AUTO_DISCOVER_TV" != "true" ]; then
        return 1
    fi
    
    log_info "üîç Auto-discovering Samsung TV..."
    
    # Method 1: Try SDB devices first (most reliable)
    if discover_tv_via_sdb; then
        log_success "Samsung TV discovered via SDB: $TV_IP:$TV_PORT"
        return 0
    fi
    
    # Method 2: Network scan for Samsung TV ports
    if discover_tv_via_network_scan; then
        log_success "Samsung TV discovered via network scan: $TV_IP:$TV_PORT"
        return 0
    fi
    
    # Method 3: mDNS discovery (informational)
    discover_tv_via_mdns
    
    log_warning "Could not auto-discover Samsung TV"
    log_info "Please set SAMSUNG_TV_IP environment variable or use manual configuration"
    return 1
}

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if device is connected
check_device_connection() {
    log_info "Checking Samsung TV connection at $TV_IP:$TV_PORT..."
    
    # Check if device is reachable via ping
    if ! ping -c 1 -W 2000 $TV_IP > /dev/null 2>&1; then
        log_error "Samsung TV at $TV_IP is not reachable. Please check network connection."
        exit 1
    fi
    
    # Check SDB connection
    if [ -f "$SDB_PATH" ]; then
        log_info "Checking SDB connection..."
        if ! $SDB_PATH devices | grep -q "$TV_IP:$TV_PORT.*device"; then
            log_warning "SDB connection failed, attempting advanced recovery..."
            if ! perform_connection_recovery "quick"; then
                log_error "Connection recovery failed, but continuing..."
            fi
        else
            log_success "SDB connected to Samsung TV"
        fi
    else
        log_warning "SDB not found at $SDB_PATH, skipping SDB check"
    fi
    
    log_success "Samsung TV is reachable at $TV_IP"
}

# Reset SDB connection function
reset_sdb_connection() {
    log_info "üîÑ Resetting SDB connection..."
    
    # Disconnect from the TV
    $SDB_PATH disconnect $TV_IP:$TV_PORT 2>/dev/null || true
    
    # Kill SDB server
    $SDB_PATH kill-server
    
    # Start SDB server
    $SDB_PATH start-server
    
    # Wait a moment for server to start
    sleep 2
    
    # Connect to the TV
    if $SDB_PATH connect $TV_IP:$TV_PORT; then
        log_success "SDB connection reset successfully"
        return 0
    else
        log_warning "Failed to reset SDB connection, but continuing..."
        return 1
    fi
}

# Advanced connection recovery using the dedicated script
perform_connection_recovery() {
    local recovery_type="${1:-full}"
    log_info "üîÑ Performing $recovery_type connection recovery..."
    
    if [ -f "./reset-connection.sh" ]; then
        case "$recovery_type" in
            "quick")
                ./reset-connection.sh --quick
                ;;
            "full")
                ./reset-connection.sh --full
                ;;
            "check")
                ./reset-connection.sh --check
                ;;
            *)
                ./reset-connection.sh --full
                ;;
        esac
        return $?
    else
        log_warning "reset-connection.sh not found, using basic recovery..."
        reset_sdb_connection
        return $?
    fi
}

# Check if Appium is running
is_appium_running() {
    curl -s "http://localhost:$APPIUM_PORT/status" > /dev/null 2>&1
}

# Start Appium server
start_appium() {
    if is_appium_running; then
        log_success "Appium is already running on port $APPIUM_PORT"
        return 0
    fi
    
    log_info "Starting Appium server on port $APPIUM_PORT..."
    
    # Start Appium in background
    appium server --base-path / --relaxed-security --port $APPIUM_PORT > appium.log 2>&1 &
    APPIUM_PID=$!
    
    # Wait for Appium to start (max 30 seconds)
    local count=0
    while [ $count -lt 30 ]; do
        if is_appium_running; then
            log_success "Appium server started successfully (PID: $APPIUM_PID)"
            return 0
        fi
        sleep 1
        count=$((count + 1))
    done
    
    log_error "Failed to start Appium server within 30 seconds"
    exit 1
}

# Stop Appium server
stop_appium() {
    if is_appium_running; then
        log_info "Stopping Appium server..."
        pkill -f "appium.*--port.*$APPIUM_PORT" || true
        sleep 2
        if is_appium_running; then
            log_warning "Appium still running, force killing..."
            pkill -9 -f "appium.*--port.*$APPIUM_PORT" || true
        fi
        log_success "Appium server stopped"
    fi
}

# Set environment variables
setup_environment() {
    log_info "Setting up environment variables..."
    export TEST_APPIUM_TIZEN_RC_TOKEN="$RC_TOKEN"
    export TEST_APPIUM_TIZEN_CHROMEDRIVER="$(pwd)/chromedriver/chromedriver"
    export SAMSUNG_TV_IP="$TV_IP"
    export SAMSUNG_TV_PORT="$TV_PORT"
    export SAMSUNG_APP_PACKAGE="$APP_PACKAGE"
    log_success "Environment variables set"
    log_info "RC_TOKEN: $RC_TOKEN"
    log_info "CHROMEDRIVER: $TEST_APPIUM_TIZEN_CHROMEDRIVER"
}

# Map test aliases to actual files
get_test_file() {
    local test_param="$1"
    
    case "$test_param" in
        "@loginTest"|"@login")
            echo "features/validLogin.feature"
            ;;
        "@archiveTest"|"@archive")
            echo "features/archiveAndFreeGamesTmobileUser.feature"
            ;;
        "@homeTest"|"@home")
            echo "features/homePageForgeFreeUser.feature"
            ;;
        "@settingsTest"|"@settings")
            echo "features/settingsPageMenu.feature"
            ;;
        "@settingsMenuTest"|"@settingsMenu")
            echo "features/settingsMenuVerification.feature"
            ;;
        "@simpleSettingsTest"|"@simpleSettings")
            echo "features/simpleSettingsTest.feature"
            ;;
        "@enhancedSettingsTest"|"@enhancedSettings")
            echo "features/enhancedSettingsTest.feature"
            ;;
        "@actualSettingsTest"|"@actualSettings")
            echo "features/actualSettingsTest.feature"
            ;;
        "@textVerificationTest"|"@textVerification")
            echo "features/textVerificationExample.feature"
            ;;
        "@debugPageSource"|"@debug")
            echo "features/debugPageSource.feature"
            ;;
        "@robustLoginTest"|"@robustLogin")
            echo "features/robustLogin.feature"
            ;;
        "@clickOnlySettingsTest"|"@clickOnlySettings")
            echo "features/clickOnlySettingsTest.feature"
            ;;
        "@svodVideoPlaybackTest"|"@svodVideo"|"@videoPlayback")
            echo "features/svodVideoPlaybackTest.feature"
            ;;
        "@debugHomePage"|"@debugHome")
            echo "features/debugHomePage.feature"
            ;;
        "@simpleHomePageDebug"|"@simpleDebug")
            echo "features/simpleHomePageDebug.feature"
            ;;
        "@improvedSvodTest"|"@improvedSvod")
            echo "features/improvedSvodTest.feature"
            ;;
        "@specificTileTest"|"@specificTile")
            echo "features/specificTileTest.feature"
            ;;
        "@carouselNavigationTest"|"@carouselNav")
            echo "features/carouselNavigationTest.feature"
            ;;
        "@gamePageNavigationTest"|"@gamePageNav")
            echo "features/gamePageNavigationTest.feature"
            ;;
        "@crossPageNavigationTest"|"@crossPageNav")
            echo "features/crossPageNavigationTest.feature"
            ;;
        "@debugGamesPage"|"@debugGames")
            echo "features/debugGamesPage.feature"
            ;;
        "@gamesPageTestCases"|"@gamesPageTests")
            echo "features/gamesPageTestCases.feature"
            ;;
        "@simpleGamesPageTest"|"@simpleGames")
            echo "features/simpleGamesPageTest.feature"
            ;;
        "@gamePlaybackByPk"|"@gamePlayback")
            echo "features/gamePlaybackByPk.feature"
            ;;
        "@simpleGamePlayback"|"@simplePlayback")
            echo "features/simpleGamePlayback.feature"
            ;;
        "@mvpdGamePlayback"|"@mvpdPlayback")
            echo "features/mvpdGamePlayback.feature"
            ;;
        "@devEnvironmentSelection"|"@devEnv")
            echo "features/devEnvironmentSelection.feature"
            ;;
        "@onboardingBypass"|"@bypass")
            echo "features/onboardingBypass.feature"
            ;;
        "@simpleDevEnv"|"@simpleDevEnvironment")
            echo "features/simpleDevEnvironmentTest.feature"
            ;;
        "@mediaPlayerTest"|"@mediaPlayer")
            echo "features/mediaPlayerTest.feature"
            ;;
        "@comprehensiveMediaPlayer"|"@comprehensiveMedia"|"@fullMediaTest")
            echo "features/comprehensiveMediaPlayerTest.feature"
            ;;
        "@gamePkTest"|"@gamePk"|"@specificGameTest")
            echo "features/comprehensiveMediaPlayerTest.feature"
            ;;
        "@gamesPageElementCapture"|"@elementCapture")
            echo "features/gamesPageElementCapture.feature"
            ;;
        "@realMediaPlayerCapture"|"@realMediaCapture"|"@mediaCapture")
            echo "features/realMediaPlayerCapture.feature"
            ;;
        "@devCalendar"|"devCalendar"|"@calendar")
            echo "features/core-app/calendar/devCalendar.feature"
            ;;
        "@debugCalendarElements"|"@debugCalendar"|"@calendarDebug")
            echo "features/debugCalendarElements.feature"
            ;;
        "@workingCalendarTest"|"@workingCalendar"|"@calendarWorking")
            echo "features/workingCalendarTest.feature"
            ;;
        *)
            # If it's not an alias, assume it's a direct file path
            echo "$test_param"
            ;;
    esac
}

# Run the test with retry logic
run_test() {
    local test_spec="$1"
    local test_file=$(get_test_file "$test_spec")
    local max_retries=3
    local retry_count=0
    
    if [ ! -f "$test_file" ]; then
        log_error "Test file not found: $test_file"
        log_info "Available test aliases:"
        log_info "  @loginTest - Login functionality test"
        log_info "  @archiveTest - Archive and free games test"
        log_info "  @homeTest - Home page test"
            log_info "  @settingsTest - Settings menu test"
            log_info "  @settingsMenuTest - Settings menu verification test"
            log_info "  @enhancedSettingsTest - Enhanced settings test with click and Enter"
            log_info "  @actualSettingsTest - Actual settings test with discovered menu options"
            log_info "  @textVerificationTest - Text verification examples"
            log_info "  @clickOnlySettingsTest - Click only settings test (no Enter key)"
            log_info "  @svodVideoPlaybackTest - SVOD video playback test"
        exit 1
    fi
    
    # Set up environment variables including RC token
    setup_environment
    
    log_info "Running test: $test_file"
    log_info "Max retries: $max_retries"
    
    # Run the WebDriverIO test with retry logic
    while [ $retry_count -lt $max_retries ]; do
        retry_count=$((retry_count + 1))
        
        if [ $retry_count -eq 1 ]; then
            log_info "üöÄ Test attempt $retry_count of $max_retries"
        else
            log_warning "üîÑ Retry attempt $retry_count of $max_retries"
            log_info "Performing connection recovery before retry..."
            perform_connection_recovery "quick" > /dev/null 2>&1 || true
            sleep 3
        fi
        
        if npm run wdio -- --spec="$test_file"; then
            log_success "‚úÖ Test completed successfully on attempt $retry_count!"
            return 0
        else
            if [ $retry_count -lt $max_retries ]; then
                log_warning "‚ùå Test failed on attempt $retry_count, will retry..."
                sleep 5
            else
                log_error "‚ùå Test failed after $max_retries attempts!"
                return 1
            fi
        fi
    done
    
    exit 1
}

# Global flag to track if cleanup is needed
CLEANUP_NEEDED=false

# Cleanup function
cleanup() {
    # Only run cleanup if it's actually needed (e.g., after test runs)
    if [ "$CLEANUP_NEEDED" = false ]; then
        return 0
    fi
    
    log_info "Cleaning up..."
    
    # Use the advanced recovery script for cleanup if available
    if [ -f "./reset-connection.sh" ]; then
        log_info "Using advanced cleanup with reset-connection.sh..."
        # Run cleanup with timeout to prevent hanging
        timeout 10 ./reset-connection.sh --quick > /dev/null 2>&1 || true
    else
        # Fallback to basic cleanup
        log_info "Using basic cleanup..."
        
        # Kill any hanging WebDriver sessions
        pkill -f "chromedriver" 2>/dev/null || true
        pkill -f "appium" 2>/dev/null || true
        
        # Reset SDB connection if it seems stuck
        if [ -f "$SDB_PATH" ]; then
            log_info "Resetting SDB connection during cleanup..."
            timeout 5 bash -c "reset_sdb_connection" > /dev/null 2>&1 || true
        fi
    fi
    
    # Don't auto-stop Appium as it might be used for other tests
    # stop_appium
    log_info "Cleanup completed"
}

# Main execution
main() {
    local command="$1"
    local test_spec="$2"
    
    # Setup Node.js version first (before logging functions are used)
    # We need to do this early but after the script starts
    
    # Load configuration file early for all commands
    load_config
    
    case "$command" in
        "test")
            if [ -z "$test_spec" ]; then
                log_error "Test specification required"
                log_info "Usage: ./run test <test_alias_or_file>"
                log_info "Example: ./run test @loginTest"
                exit 1
            fi
            
            # Enable cleanup for test runs
            CLEANUP_NEEDED=true
            
            log_info "üöÄ Starting Samsung TV Test Runner..."
            log_info "================================================"
            
            # Setup Node.js version
            setup_node_version
            
            # Auto-discover TV if not manually configured
            if [ -z "$TV_IP" ]; then
                if auto_discover_samsung_tv; then
                    # Save the discovered configuration for future use
                    save_config
                else
                    log_warning "Proceeding with fallback configuration"
                fi
            fi
            
            # Use fallback IP if discovery failed
            if [ -z "$TV_IP" ]; then
                log_error "No TV IP discovered and no TV_IP configured in $CONFIG_FILE"
                log_info "Please set TV_IP in $CONFIG_FILE or use environment variable SAMSUNG_TV_IP"
                exit 1
            fi
            
            # Setup
            check_device_connection
            start_appium
            setup_environment
            
            log_info "================================================"
            
            # Run test
            run_test "$test_spec"
            
            ;;
        "stop")
            stop_appium
            ;;
        "discover")
            log_info "üîç Discovering Samsung TVs..."
            log_info "================================================"
            
            # Force discovery regardless of current config
            AUTO_DISCOVER_TV="true"
            TV_IP=""  # Clear current IP to force discovery
            
            if auto_discover_samsung_tv; then
                # Save the discovered configuration
                save_config
                
                log_success "Samsung TV Discovery completed!"
                echo "  Discovered TV: $TV_IP:$TV_PORT"
                echo "  RC Token: $RC_TOKEN"
                echo "  Configuration saved to: $CONFIG_FILE"
                echo ""
                log_info "The discovered TV will be used automatically for future runs."
                log_info "You can also override with environment variables:"
                echo "  export SAMSUNG_TV_IP=\"$TV_IP\""
                echo "  export SAMSUNG_TV_PORT=\"$TV_PORT\""
            else
                log_error "No Samsung TVs discovered on the network"
                log_info "Make sure your Samsung TV is:"
                log_info "  1. Connected to the same network"
                log_info "  2. Has Developer Mode enabled"
                log_info "  3. Is reachable via SDB or has remote control enabled"
            fi
            ;;
        "status")
            log_info "Samsung TV Test Runner Status:"
            echo "  TV IP: ${TV_IP:-'Auto-discover'}"
            echo "  TV Port: $TV_PORT"
            echo "  RC Token: $RC_TOKEN"
            echo "  Auto-discovery: ${AUTO_DISCOVER_TV:-false}"
            echo "  SDB Path: $SDB_PATH"
            
            if is_appium_running; then
                echo "  Appium: ‚úÖ Running on port $APPIUM_PORT"
            else
                echo "  Appium: ‚ùå Not running"
            fi
            
            if [ -n "$TV_IP" ]; then
                if ping -c 1 -W 2000 $TV_IP > /dev/null 2>&1; then
                    echo "  TV Connection: ‚úÖ Reachable at $TV_IP"
                else
                    echo "  TV Connection: ‚ùå Not reachable at $TV_IP"
                fi
            else
                echo "  TV Connection: ‚ö†Ô∏è No IP configured (will auto-discover)"
            fi
            
            if [ -f "$SDB_PATH" ]; then
                echo "  SDB Status: ‚úÖ Available"
            else
                echo "  SDB Status: ‚ùå Not found at $SDB_PATH"
            fi
            ;;
        "recover"|"recovery")
            local recovery_type="${2:-full}"
            log_info "üîÑ Samsung TV Connection Recovery"
            log_info "================================================"
            
            # Load configuration
            load_config
            
            case "$recovery_type" in
                "quick"|"q")
                    log_info "Performing quick recovery (processes + SDB)..."
                    perform_connection_recovery "quick"
                    ;;
                "full"|"f")
                    log_info "Performing full recovery (processes + SDB + app launch)..."
                    perform_connection_recovery "full"
                    ;;
                "check"|"c")
                    log_info "Checking connection status..."
                    perform_connection_recovery "check"
                    ;;
                *)
                    log_info "Performing full recovery..."
                    perform_connection_recovery "full"
                    ;;
            esac
            ;;
        "reset")
            log_info "üîÑ Resetting Samsung TV Connection"
            log_info "================================================"
            
            # Load configuration
            load_config
            
            log_info "Killing all processes and resetting connections..."
            perform_connection_recovery "full"
            ;;
        *)
            log_info "Samsung TV Test Runner"
            log_info "Usage:"
            log_info "  ./run test <test_alias_or_file>  - Run a specific test"
            log_info "  ./run discover                   - Auto-discover Samsung TVs on network"
            log_info "  ./run stop                       - Stop Appium server"
            log_info "  ./run status                     - Check system status"
            log_info "  ./run recover [quick|full|check] - Recover TV connection"
            log_info "  ./run reset                      - Full connection reset"
            log_info ""
            log_info "Environment Variables:"
            log_info "  SAMSUNG_TV_IP         - Override TV IP address"
            log_info "  SAMSUNG_TV_PORT       - Override TV port (default: 26101)"
            log_info "  SAMSUNG_TV_RC_TOKEN   - Override remote control token"
            log_info "  SAMSUNG_APP_PACKAGE   - Override app package ID"
            log_info "  AUTO_DISCOVER_TV      - Enable/disable auto-discovery (default: true)"
            log_info ""
            log_info "Test Aliases:"
            log_info "  @loginTest   - Run login functionality test"
            log_info "  @archiveTest - Run archive and free games test"
            log_info "  @homeTest    - Run home page test"
                log_info "  @settingsTest - Run settings menu test"
                log_info "  @settingsMenuTest - Run settings menu verification test"
                log_info "  @enhancedSettingsTest - Run enhanced settings test with click and Enter"
                log_info "  @actualSettingsTest - Run actual settings test with discovered menu options"
                log_info "  @textVerificationTest - Run text verification examples"
                log_info "  @clickOnlySettingsTest - Run click only settings test (no Enter key)"
                log_info "  @svodVideoPlaybackTest - Run SVOD video playback test"
            log_info ""
            log_info "Examples:"
            log_info "  ./run test @loginTest                    # Auto-discover TV and run login test"
            log_info "  ./run discover                           # Find Samsung TVs on network"
            log_info "  SAMSUNG_TV_IP=192.168.1.100 ./run test @loginTest  # Use specific TV IP"
            log_info "  ./run test features/validLogin.feature  # Run specific test file"
            ;;
    esac
}

# Set trap for cleanup
trap cleanup EXIT

# Execute main function with all arguments
main "$@"

# Explicitly exit with the last command's exit code
exit $?
